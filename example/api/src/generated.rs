/// File auto generated by npmjs.com/openapi-preset-actix
pub mod api {

    pub struct CardboxApiInternal {
        api: ::actix_swagger::Api,
    }

    pub fn create() -> CardboxApiInternal {
        CardboxApiInternal { api: ::actix_swagger::Api::new() }
    }

    impl ::actix_web::dev::HttpServiceFactory for CardboxApiInternal {
        fn register(self, config: &mut ::actix_web::dev::AppService) {
            self.api.register(config);
        }
    }


    impl CardboxApiInternal {

        pub fn bind_auth_done<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::auth_done::Response,
                        super::paths::auth_done::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/accesso/auth.done".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_auth_params<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::auth_params::Response,
                        super::paths::auth_params::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/accesso/auth.params".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_search<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_search::Response,
                        super::paths::cards_search::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.search".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_feed<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_feed::Response,
                        super::paths::cards_feed::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.feed".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_list<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_list::Response,
                        super::paths::cards_list::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.list".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_get<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_get::Response,
                        super::paths::cards_get::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.get".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_create<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_create::Response,
                        super::paths::cards_create::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.create".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_edit<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_edit::Response,
                        super::paths::cards_edit::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.edit".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_delete<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_delete::Response,
                        super::paths::cards_delete::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.delete".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_save<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_save::Response,
                        super::paths::cards_save::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.save".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_session_get<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::session_get::Response,
                        super::paths::session_get::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/session.get".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_session_delete<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::session_delete::Response,
                        super::paths::session_delete::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/session.delete".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_users_search<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::users_search::Response,
                        super::paths::users_search::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/users.search".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_users_get<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::users_get::Response,
                        super::paths::users_get::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/users.get".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

    }


}

pub mod paths {
    use super::components::responses;
    pub mod auth_done {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::AuthDoneSuccess)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Auth done failed")]
            Unauthorized(#[source] responses::AuthDoneFailed),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::Unauthorized(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod auth_params {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::AuthUrlSuccess)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod cards_search {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsSearchOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod cards_feed {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsFeedOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod cards_list {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsListOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards list bad request")]
            BadRequest(#[source] responses::CardsListBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_get {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsGetOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards get bad request")]
            BadRequest(#[source] responses::CardsGetBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_create {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsCreateOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards create bad request")]
            BadRequest(#[source] responses::CardsCreateBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_edit {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsEditOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards edit bad request")]
            BadRequest(#[source] responses::CardsEditBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_delete {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsDeleteOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards delete bad request")]
            BadRequest(#[source] responses::CardsDeleteBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_save {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsSaveOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards save bad request")]
            BadRequest(#[source] responses::CardsSaveBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod session_get {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::SessionGetSuccess)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Session get unauthorized")]
            Unauthorized(#[source] #[serde(skip)] ::eyre::Report),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::Unauthorized(_) => None,
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod session_delete {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok => ::actix_web::HttpResponse::build(StatusCode::OK).finish()
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Session delete failure")]
            BadRequest(#[source] responses::SessionDeleteFailure),
            #[error("Session delete unauthorized")]
            Unauthorized(#[source] #[serde(skip)] ::eyre::Report),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::Unauthorized(_) => None,
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod users_search {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::UsersSearchOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod users_get {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::UsersGetOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Users get bad request")]
            BadRequest(#[source] responses::UsersGetBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type: ::std::option::Option<ContentType> = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

}

pub mod components {

    pub mod responses {
        use super::schemas;
        pub type AuthDoneFailed = schemas::AuthDoneFailedResponse;
         
        pub type AuthDoneSuccess = schemas::AuthDoneSuccessResponse;
         
        pub type AuthUrlSuccess = schemas::AuthUrlSuccessResponse;
         
        pub type SessionGetSuccess = schemas::SessionGetSuccessResponse;
         
        pub type SessionDeleteFailure = schemas::SessionDeleteFailureResponse;
         
        pub type CardsSearchOk = schemas::CardsSearchOkResponse;
         
        pub type CardsFeedOk = schemas::CardsFeedOkResponse;
         
        pub type CardsListOk = schemas::CardsListOkResponse;
         
        pub type CardsListBadRequest = schemas::CardsListBadRequestResponse;
         
        pub type CardsGetOk = schemas::CardsGetOkResponse;
         
        pub type CardsGetBadRequest = schemas::CardsGetBadRequestResponse;
         
        pub type CardsCreateOk = schemas::CardsCreateOkResponse;
         
        pub type CardsCreateBadRequest = schemas::CardsCreateBadRequestResponse;
         
        pub type CardsEditOk = schemas::CardsEditOkResponse;
         
        pub type CardsEditBadRequest = schemas::CardsEditBadRequestResponse;
         
        pub type CardsDeleteOk = schemas::CardsDeleteOkResponse;
         
        pub type CardsDeleteBadRequest = schemas::CardsDeleteBadRequestResponse;
         
        pub type CardsSaveOk = schemas::CardsSaveOkResponse;
         
        pub type CardsSaveBadRequest = schemas::CardsSaveBadRequestResponse;
         
        pub type UsersSearchOk = schemas::UsersSearchOkResponse;
         
        pub type UsersGetOk = schemas::UsersGetOkResponse;
         
        pub type UsersGetBadRequest = schemas::UsersGetBadRequestResponse;
         
    }

    pub mod request_bodies {
        use super::schemas;
        pub type SessionDelete = ::actix_web::web::Json<schemas::SessionDeleteRequestBody>;
         
        pub type AuthDone = ::actix_web::web::Json<schemas::AuthDoneRequestBody>;
         
        pub type AuthParams = ::actix_web::web::Json<schemas::AuthParamsRequestBody>;
         
        pub type CardsSearch = ::actix_web::web::Json<schemas::CardsSearchRequestBody>;
         
        pub type CardsList = ::actix_web::web::Json<schemas::CardsListRequestBody>;
         
        pub type CardsGet = ::actix_web::web::Json<schemas::CardsGetRequestBody>;
         
        pub type CardsCreate = ::actix_web::web::Json<schemas::CardsCreateRequestBody>;
         
        pub type CardsEdit = ::actix_web::web::Json<schemas::CardsEditRequestBody>;
         
        pub type CardsDelete = ::actix_web::web::Json<schemas::CardsDeleteRequestBody>;
         
        pub type CardsSave = ::actix_web::web::Json<schemas::CardsSaveRequestBody>;
         
        pub type UsersSearch = ::actix_web::web::Json<schemas::UsersSearchRequestBody>;
         
        pub type UsersGet = ::actix_web::web::Json<schemas::UsersGetRequestBody>;
         
    }

    pub mod schemas {
        use serde::{Deserialize, Serialize};
        use super::super::components;

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionDeleteRequestBody {
            #[serde(rename = "deleteAllSessions")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub delete_all_sessions: ::std::option::Option<bool>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum AuthDoneFailedResponseError {
            #[serde(rename = "accesso_failed")]
            AccessoFailed,

            #[serde(rename = "try_later")]
            TryLater,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthDoneFailedResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::AuthDoneFailedResponseError>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthDoneSuccessResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub user: ::std::option::Option<components::schemas::SessionUser>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthUrlSuccessResponse {
            #[serde(rename = "accessoUrl")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub accesso_url: ::std::option::Option<::std::string::String>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionGetSuccessResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub user: ::std::option::Option<components::schemas::SessionUser>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum SessionDeleteFailureResponseError {
            #[serde(rename = "invalid_payload")]
            InvalidPayload,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionDeleteFailureResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::SessionDeleteFailureResponseError>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionUser {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(rename = "firstName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub first_name: ::std::option::Option<::std::string::String>,

            #[serde(rename = "lastName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub last_name: ::std::option::Option<::std::string::String>,

        }

        pub type UserSocials = ::std::vec::Vec<components::schemas::UserSocial>;
         
        pub type UserRoles = ::std::vec::Vec<::std::string::String>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct User {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub username: ::std::option::Option<::std::string::String>,

            #[serde(rename = "firstName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub first_name: ::std::option::Option<::std::string::String>,

            #[serde(rename = "lastName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub last_name: ::std::option::Option<::std::string::String>,

            pub bio: ::std::option::Option<::std::string::String>,

            pub avatar: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub socials: ::std::option::Option<components::schemas::UserSocials>,

            pub work: ::std::option::Option<::std::string::String>,

            pub roles: components::schemas::UserRoles,

        }

        pub type CardContentItem = ::std::collections::HashMap<::std::string::String, ::serde_json::value::Value>;
         
        pub type CardContent = ::std::vec::Vec<components::schemas::CardContentItem>;
         
        pub type CardTags = ::std::vec::Vec<::std::string::String>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct Card {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub title: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub content: ::std::option::Option<components::schemas::CardContent>,

            #[serde(rename = "createdAt")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::Utc>>,

            #[serde(rename = "updatedAt")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::Utc>>,

            #[serde(rename = "authorId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub author_id: ::std::option::Option<::uuid::Uuid>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub tags: ::std::option::Option<components::schemas::CardTags>,

            pub summary: ::std::option::Option<::std::string::String>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UserSocial {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub r#type: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub link: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub username: ::std::option::Option<::std::string::String>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthDoneRequestBody {
            #[serde(rename = "authorizationCode")]
            pub authorization_code: ::std::string::String,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthParamsRequestBody {
            pub state: ::std::string::String,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsSearchRequestBody {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub query: ::std::option::Option<::std::string::String>,

        }

        pub type CardsSearchOkResponseCards = ::std::vec::Vec<components::schemas::Card>;
         
        pub type CardsSearchOkResponseUsers = ::std::vec::Vec<components::schemas::User>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsSearchOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub cards: ::std::option::Option<components::schemas::CardsSearchOkResponseCards>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub users: ::std::option::Option<components::schemas::CardsSearchOkResponseUsers>,

        }

        pub type CardsFeedOkResponseTopCards = ::std::vec::Vec<components::schemas::Card>;
         
        pub type CardsFeedOkResponseTopUsers = ::std::vec::Vec<components::schemas::User>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsFeedOkResponseTop {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub cards: ::std::option::Option<components::schemas::CardsFeedOkResponseTopCards>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub users: ::std::option::Option<components::schemas::CardsFeedOkResponseTopUsers>,

        }

        pub type CardsFeedOkResponseLatestCards = ::std::vec::Vec<components::schemas::Card>;
         
        pub type CardsFeedOkResponseLatestUsers = ::std::vec::Vec<components::schemas::User>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsFeedOkResponseLatest {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub cards: ::std::option::Option<components::schemas::CardsFeedOkResponseLatestCards>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub users: ::std::option::Option<components::schemas::CardsFeedOkResponseLatestUsers>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsFeedOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub top: ::std::option::Option<components::schemas::CardsFeedOkResponseTop>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub latest: ::std::option::Option<components::schemas::CardsFeedOkResponseLatest>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsListRequestBody {
            #[serde(rename = "authorId")]
            pub author_id: ::uuid::Uuid,

            pub favorites: bool,

        }

        pub type CardsListOkResponseCards = ::std::vec::Vec<components::schemas::Card>;
         
        pub type CardsListOkResponseUsers = ::std::vec::Vec<components::schemas::User>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsListOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub cards: ::std::option::Option<components::schemas::CardsListOkResponseCards>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub users: ::std::option::Option<components::schemas::CardsListOkResponseUsers>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum CardsListBadRequestResponseCode {
            #[serde(rename = "invalid_params")]
            InvalidParams,

            #[serde(rename = "unauthorized")]
            Unauthorized,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsListBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<bool>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub code: ::std::option::Option<components::schemas::CardsListBadRequestResponseCode>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsGetRequestBody {
            #[serde(rename = "cardId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card_id: ::std::option::Option<::uuid::Uuid>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsGetOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card: ::std::option::Option<components::schemas::Card>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum CardsGetBadRequestResponseCode {
            #[serde(rename = "card_not_found")]
            CardNotFound,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsGetBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<bool>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub code: ::std::option::Option<components::schemas::CardsGetBadRequestResponseCode>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsCreateRequestBodyContent {

        }

        pub type CardsCreateRequestBodyTags = ::std::vec::Vec<::std::string::String>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsCreateRequestBody {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub title: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub content: ::std::option::Option<components::schemas::CardsCreateRequestBodyContent>,

            pub tags: components::schemas::CardsCreateRequestBodyTags,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsCreateOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card: ::std::option::Option<components::schemas::Card>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum CardsCreateBadRequestResponseError {
            #[serde(rename = "empty_title")]
            EmptyTitle,

            #[serde(rename = "invalid_content")]
            InvalidContent,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsCreateBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::CardsCreateBadRequestResponseError>,

        }

        pub type CardsEditRequestBodyTags = ::std::vec::Vec<::std::string::String>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsEditRequestBody {
            #[serde(rename = "cardId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card_id: ::std::option::Option<::uuid::Uuid>,

            pub title: ::std::string::String,

            pub content: ::std::collections::HashMap<::std::string::String, ::serde_json::value::Value>,

            pub tags: components::schemas::CardsEditRequestBodyTags,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsEditOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card: ::std::option::Option<components::schemas::Card>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum CardsEditBadRequestResponseError {
            #[serde(rename = "card_not_found")]
            CardNotFound,

            #[serde(rename = "invalid_payload")]
            InvalidPayload,

            #[serde(rename = "no_access")]
            NoAccess,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsEditBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::CardsEditBadRequestResponseError>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsDeleteRequestBody {
            #[serde(rename = "cardId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card_id: ::std::option::Option<::uuid::Uuid>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsDeleteOkResponse {
            #[serde(rename = "cardId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card_id: ::std::option::Option<::uuid::Uuid>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum CardsDeleteBadRequestResponseError {
            #[serde(rename = "card_not_found")]
            CardNotFound,

            #[serde(rename = "no_access")]
            NoAccess,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsDeleteBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::CardsDeleteBadRequestResponseError>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsSaveRequestBody {
            #[serde(rename = "cardId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card_id: ::std::option::Option<::uuid::Uuid>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsSaveOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub card: ::std::option::Option<components::schemas::Card>,

            #[serde(rename = "boxId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub box_id: ::std::option::Option<::uuid::Uuid>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum CardsSaveBadRequestResponseCode {
            #[serde(rename = "already_saved")]
            AlreadySaved,

            #[serde(rename = "card_not_found")]
            CardNotFound,

            #[serde(rename = "no_access")]
            NoAccess,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct CardsSaveBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<bool>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub code: ::std::option::Option<components::schemas::CardsSaveBadRequestResponseCode>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UsersSearchRequestBody {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub query: ::std::option::Option<::std::string::String>,

        }

        pub type UsersSearchOkResponseUsers = ::std::vec::Vec<components::schemas::User>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct UsersSearchOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub users: ::std::option::Option<components::schemas::UsersSearchOkResponseUsers>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UsersGetRequestBody {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub username: ::std::option::Option<::std::string::String>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UsersGetOkResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub user: ::std::option::Option<components::schemas::User>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum UsersGetBadRequestResponseCode {
            #[serde(rename = "user_not_found")]
            UserNotFound,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UsersGetBadRequestResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<bool>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub code: ::std::option::Option<components::schemas::UsersGetBadRequestResponseCode>,

        }

    }

}
