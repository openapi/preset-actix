/// File auto generated by npmjs.com/openapi-preset-actix
pub mod api {

    pub struct CardboxApiInternal {
        api: ::actix_swagger::Api,
    }

    pub fn create() -> CardboxApiInternal {
        CardboxApiInternal { api: ::actix_swagger::Api::new() }
    }

    impl ::actix_web::dev::HttpServiceFactory for CardboxApiInternal {
        fn register(self, config: &mut ::actix_web::dev::AppService) {
            self.api.register(config);
        }
    }


    impl CardboxApiInternal {

        pub fn bind_auth_done<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::auth_done::Response,
                        super::paths::auth_done::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/accesso/auth.done".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_auth_params<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::auth_params::Response,
                        super::paths::auth_params::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/accesso/auth.params".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_search<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_search::Response,
                        super::paths::cards_search::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.search".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_feed<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_feed::Response,
                        super::paths::cards_feed::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.feed".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_list<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_list::Response,
                        super::paths::cards_list::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.list".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_get<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_get::Response,
                        super::paths::cards_get::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.get".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_create<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_create::Response,
                        super::paths::cards_create::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.create".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_edit<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_edit::Response,
                        super::paths::cards_edit::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.edit".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_delete<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_delete::Response,
                        super::paths::cards_delete::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.delete".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_cards_save<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::cards_save::Response,
                        super::paths::cards_save::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/cards.save".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_session_get<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::session_get::Response,
                        super::paths::session_get::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/session.get".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_session_delete<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::session_delete::Response,
                        super::paths::session_delete::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/session.delete".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_users_search<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::users_search::Response,
                        super::paths::users_search::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/users.search".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

        pub fn bind_users_get<F, T, R>(mut self, handler: F) -> Self
        where
            F: ::actix_web::dev::Handler<T, R>,
            T: ::actix_web::FromRequest + 'static,
            R: ::std::future::Future<
                    Output = ::std::result::Result<
                        super::paths::users_get::Response,
                        super::paths::users_get::Error,
                    >,
                > + 'static,
        {
            self.api = self
                .api
                .bind("/users.get".to_owned(), ::actix_swagger::Method::POST, handler);
            self
        }

    }


}

pub mod paths {
    use super::components::responses;
    pub mod auth_done {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::AuthDoneSuccess)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Auth done failed")]
            Unauthorized(#[source] responses::AuthDoneFailed),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::Unauthorized(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod auth_params {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::AuthUrlSuccess)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod cards_search {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsSearchOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod cards_feed {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsFeedOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod cards_list {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsListOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards list bad request")]
            BadRequest(#[source] responses::CardsListBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_get {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsGetOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards get bad request")]
            BadRequest(#[source] responses::CardsGetBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_create {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsCreateOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards create bad request")]
            BadRequest(#[source] responses::CardsCreateBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_edit {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsEditOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards edit bad request")]
            BadRequest(#[source] responses::CardsEditBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_delete {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsDeleteOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards delete bad request")]
            BadRequest(#[source] responses::CardsDeleteBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod cards_save {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::CardsSaveOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Cards save bad request")]
            BadRequest(#[source] responses::CardsSaveBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod session_get {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::SessionGetSuccess)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Session get unauthorized")]
            Unauthorized(#[source] #[serde(skip)] ::eyre::Report),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::Unauthorized(_) => None,
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod session_delete {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok => ::actix_web::HttpResponse::build(StatusCode::OK).finish()
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Session delete failure")]
            BadRequest(#[source] responses::SessionDeleteFailure),
            #[error("Session delete unauthorized")]
            Unauthorized(#[source] #[serde(skip)] ::eyre::Report),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::Unauthorized(_) => StatusCode::UNAUTHORIZED,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::Unauthorized(_) => None,
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

    pub mod users_search {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::UsersSearchOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            
        }
    }

    pub mod users_get {
        use super::responses;
        use ::actix_swagger::ContentType;
        use ::actix_web::http::StatusCode;

        #[derive(Debug, ::serde::Serialize)]
        #[serde(untagged)]
        pub enum Response { 
            Ok(responses::UsersGetOk)
        }
        
        impl ::actix_web::Responder for Response {
            fn respond_to(self, _: &::actix_web::HttpRequest) -> ::actix_web::HttpResponse {
                match self { 
                    Response::Ok(body) => ::actix_web::HttpResponse::build(StatusCode::OK).json(body)
                }
            }
        }

        #[derive(Debug, ::serde::Serialize, ::thiserror::Error)]
        #[serde(untagged)]
        pub enum Error {
            #[error("Users get bad request")]
            BadRequest(#[source] responses::UsersGetBadRequest),
            #[error(transparent)]
            InternalServerError(#[from] #[serde(skip)] ::eyre::Report)
        }
        
        impl ::actix_web::ResponseError for Error {
            fn status_code(&self) -> StatusCode {
                match self { 
                    Self::BadRequest(_) => StatusCode::BAD_REQUEST,
                    Self::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR
                }
            }
            fn error_response(&self) -> ::actix_web::HttpResponse {
                let content_type = match self {
                    Self::BadRequest(_) => Some(ContentType::Json),
                    Self::InternalServerError(_) => None
                };
                
                let mut res = &mut ::actix_web::HttpResponse::build(self.status_code());
                if let Some(content_type) = content_type {
                    res = res.content_type(content_type.to_string());

                    match content_type {
                        ContentType::Json => res.json(self),
                        ContentType::FormData => res.body(serde_plain::to_string(self).unwrap()),
                    }
                } else {
                    ::actix_web::HttpResponse::InternalServerError().finish()
                }
            }
        }
    }

}

pub mod components {

    pub mod responses {
        use super::schemas;
        pub type AuthDoneFailed = schemas::AuthDoneFailedResponse;
         
        pub type AuthDoneSuccess = schemas::AuthDoneSuccessResponse;
         
        pub type AuthUrlSuccess = schemas::AuthUrlSuccessResponse;
         
        pub type SessionGetSuccess = schemas::SessionGetSuccessResponse;
         
        pub type SessionDeleteFailure = schemas::SessionDeleteFailureResponse;
         
    }

    pub mod request_bodies {
        use super::schemas;
        pub type SessionDelete = ::actix_web::web::Json<schemas::SessionDeleteRequestBody>;
         
    }

    pub mod schemas {
        use serde::{Deserialize, Serialize};
        use super::super::components;

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionDeleteRequestBody {
            #[serde(rename = "deleteAllSessions")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub delete_all_sessions: ::std::option::Option<bool>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum AuthDoneFailedResponseError {
            #[serde(rename = "accesso_failed")]
            AccessoFailed,

            #[serde(rename = "try_later")]
            TryLater,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthDoneFailedResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::AuthDoneFailedResponseError>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthDoneSuccessResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub user: ::std::option::Option<components::schemas::SessionUser>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct AuthUrlSuccessResponse {
            #[serde(rename = "accessoUrl")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub accesso_url: ::std::option::Option<::std::string::String>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionGetSuccessResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub user: ::std::option::Option<components::schemas::SessionUser>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub enum SessionDeleteFailureResponseError {
            #[serde(rename = "invalid_payload")]
            InvalidPayload,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionDeleteFailureResponse {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub error: ::std::option::Option<components::schemas::SessionDeleteFailureResponseError>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct SessionUser {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(rename = "firstName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub first_name: ::std::option::Option<::std::string::String>,

            #[serde(rename = "lastName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub last_name: ::std::option::Option<::std::string::String>,

        }

        pub type UserSocials = ::std::vec::Vec<components::schemas::UserSocial>;
         
        pub type UserRoles = ::std::vec::Vec<::std::string::String>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct User {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub username: ::std::option::Option<::std::string::String>,

            #[serde(rename = "firstName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub first_name: ::std::option::Option<::std::string::String>,

            #[serde(rename = "lastName")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub last_name: ::std::option::Option<::std::string::String>,

            pub bio: ::std::option::Option<::std::string::String>,

            pub avatar: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub socials: ::std::option::Option<components::schemas::UserSocials>,

            pub work: ::std::option::Option<::std::string::String>,

            pub roles: components::schemas::UserRoles,

        }

        pub type CardContentItem = ::std::collections::HashMap<::std::string::String, ::serde_json::value::Value>;
         
        pub type CardContent = ::std::vec::Vec<components::schemas::CardContentItem>;
         
        pub type CardTags = ::std::vec::Vec<::std::string::String>;
         
        #[derive(Debug, Serialize, Deserialize)]
        pub struct Card {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub title: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub content: ::std::option::Option<components::schemas::CardContent>,

            #[serde(rename = "createdAt")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub created_at: ::std::option::Option<::chrono::DateTime<::chrono::Utc>>,

            #[serde(rename = "updatedAt")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub updated_at: ::std::option::Option<::chrono::DateTime<::chrono::Utc>>,

            #[serde(rename = "authorId")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub author_id: ::std::option::Option<::uuid::Uuid>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub tags: ::std::option::Option<components::schemas::CardTags>,

            pub summary: ::std::option::Option<::std::string::String>,

        }

        #[derive(Debug, Serialize, Deserialize)]
        pub struct UserSocial {
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub id: ::std::option::Option<::uuid::Uuid>,

            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub r#type: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub link: ::std::option::Option<::std::string::String>,

            #[serde(skip_serializing_if = "::std::option::Option::is_none")]
            pub username: ::std::option::Option<::std::string::String>,

        }

    }

}
