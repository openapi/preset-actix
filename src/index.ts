import { FilesApi, Method, PresetConstructor, status } from 'openapi';
import { OpenAPIV3 } from 'openapi-types';
import * as changeCase from 'change-case';
import * as template from './template';
import { Components } from './components';
import { createSchema, traverseSchema } from './schemas';

const PACKAGE_NAME = 'openapi-preset-actix';

interface Options {
  fileName?: string;
}

const preset: PresetConstructor<Options> = ({ fileName = 'generated.rs' } = {}, internal) => {
  const parameters = new Components();
  const schemas = new Components();

  function addHeader(name: string, header: string) {
    parameters.addExtra(template.HeaderExtractor);
    const struct = changeCase.pascalCase(name);
    parameters.addComponent(struct, template.headerStructure(struct, header));
  }

  const apiPaths = new Map<string, { api: string; path: string }>();

  return {
    name: PACKAGE_NAME,

    onParameter(name: string, parameter: OpenAPIV3.ParameterObject) {
      if (parameter.in === 'header') {
        addHeader(name, parameter.name);
      }
    },

    onSchema(name: string, schema: OpenAPIV3.SchemaObject) {
      createSchema(schemas, internal).add(name, schema, true);
    },

    onOperation(pattern: string, method: Method, operation: OpenAPIV3.OperationObject) {
      const operationId = operation.operationId ?? pattern;
      const moduleName = changeCase.snakeCase(operationId);

      const responses = Object.entries(operation.responses ?? {}).map(([code, refOrResponse]) => {
        const response = internal.isRef(refOrResponse)
          ? (internal.resolveRef(refOrResponse.$ref) as OpenAPIV3.ResponseObject)
          : refOrResponse;

        const name = internal.isRef(refOrResponse)
          ? refOrResponse.$ref.split('/').pop()!
          : `${changeCase.pascalCase(operationId)}${changeCase.pascalCase(
              status[Number(code) as keyof typeof status]?.code ?? code,
            )}`;
        const contentType = response.content?.['application/json'] ? 'json' : undefined;

        return { code: parseInt(code, 10), contentType, name };
      });

      apiPaths.set(moduleName, {
        api: template.pathBind(operationId, pattern, method),
        path: template.pathModule(operationId, responses),
      });
    },

    build(files: FilesApi) {
      const chunks = [];

      chunks.push(
        template.mod(
          'api',
          template.apiStruct(
            internal.root().info.title,
            Array.from(apiPaths.values())
              .map((a) => a.api)
              .join(''),
          ),
        ),
      );

      chunks.push(
        template.mod(
          'paths',
          'use super::components::responses;' +
            Array.from(apiPaths.values())
              .map((a) => a.path)
              .join(''),
        ),
      );

      const components = new Set<string>();

      if (parameters.hasItems()) {
        components.add(template.mod('parameters', parameters.build()));
      }

      if (true) {
        components.add(template.mod('responses', [].join('')));
      }

      if (true) {
        components.add(template.mod('request_bodies', [].join('')));
      }

      if (schemas.hasItems()) {
        components.add(template.mod('schemas', schemas.build()));
      }

      if (components.size) {
        chunks.push(template.mod('components', Array.from(components).join('')));
      }

      files.addFile(
        fileName,
        '/// File auto generated by npmjs.com/' + PACKAGE_NAME + chunks.join(''),
      );
    },
  };
};

module.exports = preset;
